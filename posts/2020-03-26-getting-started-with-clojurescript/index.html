<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">

  

<meta name="keywords" content="programming,Clojure,ClojureScript">


<meta name="description" content="TLDR: clone this repo to get started, or this repo for a more involved example (the latter is also live here)">
<meta property="og:description" content="TLDR: clone this repo to get started, or this repo for a more involved example (the latter is also live here)">


<meta property="og:title" content="Daniel Plisetsky | Getting Started with ClojureScript">
<meta property="og:type" content="blog">



<script src="/js/lib/highlight-bundle.js" type="text/javascript"></script>
<link href="/css/highlight.min.css" rel="stylesheet" type="text/css" />





  <meta property="og:site_name" content="Daniel Plisetsky">
  <meta property="og:image" content="https://danplisetsky.github.io/img/gjiam.jpeg">
  <meta property="og:url" content="https://danplisetsky.github.io/posts/2020-03-26-getting-started-with-clojurescript/">

  <meta name="author" content="Daniel Plisetsky">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  <link rel="canonical" href="https://danplisetsky.github.io/posts/2020-03-26-getting-started-with-clojurescript/">

  <link href="/css/vendors/normalize.css" rel="stylesheet" type="text/css" />
  <link href="/css/blog.css" rel="stylesheet" type="text/css" />
  <link href="/css/vendors/font-awesome/fontawesome.min.css" rel="stylesheet" type="text/css" />
  <link href="/css/vendors/font-awesome/solid.min.css" rel="stylesheet" type="text/css" />

  <title>Daniel Plisetsky: Getting Started with ClojureScript </title>
</head>

<body>

  <header>
    <h1>
      <a href="/">
        Daniel Plisetsky
      </a>
    </h1>
  </header>

  <nav>
    <a href="/archives/">
      Blog
    </a>

    

    <a href="/projects/">
      Projects
    </a>

    

    <a href="/publications/">
      Publications
    </a>

    

    <a href="/contact/">
      Contact
    </a>

    

    <a href="https://github.com/danplisetsky" class="with-icon">
      GitHub
      <i class="fas fa-external-link-alt"></i>
    </a>

    <!-- <a href="rss" class="with-icon">
      RSS
      <i class="fas fa-rss"></i>
    </a> -->
  </nav>

  <main role="main" id='posts'>
    

<article>

  <section class="post-summary">

  

  <h2 class="post-name">Getting Started with ClojureScript</h2>

  

  <div class="post-additional-info">
    <i class="fas fa-pen-fancy"></i>
    <time class="post-published-date" datetime="Thu Mar 26 00:00:00 UTC 2020">
      March 26, 2020
    </time>
    <p class="post-tag-list">
      <a class="tags-link" href="/tags/">
        <i class="fas fa-tags"></i>
      </a>

      

      <a href="/tag/Clojure/" class="post-tag">Clojure</a>

      

      <a href="/tag/ClojureScript/" class="post-tag">ClojureScript</a>

      

      <a href="/tag/programming/" class="post-tag">programming</a>

      
    </p>
  </div>
</section>


  <p>TLDR: clone <a href="https://github.com/danplisetsky/clojurescript-template">this repo</a> to get started, or <a href="https://github.com/danplisetsky/cljs-example">this repo</a> for a more involved example (the latter is also live <a href="https://danplisetsky.github.io/cljs-example/">here</a>)</p><hr /><p>Clojure is famous for being amazing and a total bliss in every way... except when it comes to documentation. This is especially true of the <a href="https://clojurescript.org/guides/quick-start">official ClojureScript</a> website: the Quick Start guide doesn't even mention HTML, even though the idea is to compile ClojureScript to JavaScript and then reference it in an HTML file.</p><p>Let's see how we can build, step by step, a blissful ClojureScript development experience, and then we'll look at the benefits of using this weird, funny-looking, parentheses-heavy (there's a point behind them, I swear!) language.</p><h3 id="intended_audience">Intended Audience<a href="#intended_audience"><i class="fas fa-link"></i></a></h3><p>Programmers familiar with (front end) development who'd like to code like it's 2020 â€“ not 1999. If being able to save the state of your app (and modify it on the fly) between hot reloads sounds good, read on.</p><h3 id="step_0:_prerequisites">Step 0: Prerequisites<a href="#step_0:_prerequisites"><i class="fas fa-link"></i></a></h3><p>You'll need the following tools available on your PATH:</p><ul><li><a href="https://nodejs.org/en/">Node/npm</a></li><li><a href="https://clojure.org/guides/getting_started">Clojure</a></li></ul><p>If you're on a Mac, both are also available via <a href="https://brew.sh">brew</a>.</p><p>Now we can go ahead and create a folder for our project:</p><pre><code class="bash">mkdir clojurescript-template
</code></pre><h3 id="step_1:_html">Step 1: HTML<a href="#step_1:_html"><i class="fas fa-link"></i></a></h3><p>We'll start with HTML. Create a folder called <code>public</code> with the following <code>index.html</code>:</p><pre><code class="html">&lt;body&gt;
  &lt;div id="app"&gt;&lt;/div&gt;
  &lt;script src="js/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>This should look familiar to React, etc. developers. We'll manipulate the DOM from our compiled main.js and we'll render the whole app into that one <code>div</code>.</p><h3 id="step_2:_shadow_cljs_and_deps">Step 2: Shadow CLJS and Deps<a href="#step_2:_shadow_cljs_and_deps"><i class="fas fa-link"></i></a></h3><blockquote><p> <a href="https://shadow-cljs.org">shadow-cljs</a> provides everything you need to compile your ClojureScript code with a focus on simplicity and ease of use. </p></blockquote><p>Pretty much.</p><p>Let's install it first:</p><pre><code class="bash">echo '{}' &gt; package.json # we'll only be using package.json for dependency management and scripts. Feel free to add other fields (name, author, etc.)
npm i -D shadow-cljs
</code></pre><p>And then initialize a config file:</p><pre><code class="bash">./node_modules/.bin/shadow-cljs init
</code></pre><p>This will create a placeholder <code>shadow-cljs.edn</code> which looks like this:</p><pre><code class="clojure">;; shadow-cljs configuration
{:source-paths
 ["src/dev"
  "src/main"
  "src/test"]

 :dependencies
 []

 :builds
 {}}
</code></pre><p>As you can see, shadow-cljs can manage dependencies and the source code, but we'll use the now official Clojure tool for that called <a href="https://clojure.org/guides/deps_and_cli">Deps</a>, mostly because at least one popular Clojure setup, IntelliJ + Cursive, does not yet support shadow-cljs.</p><p>So, let's create a <code>deps.edn</code> file and make it look like this:</p><pre><code class="clojure">{:paths ["src/dev"]

 :deps  {thheller/shadow-cljs {:mvn/version "2.8.94"}}

 :aliases
 {:cljs
  {:extra-deps {}
   :extra-paths ["src/main" "src/test"]}}}
</code></pre><ul><li><code>:paths</code> points to the code that only Deps needs to know about</li><li><code>:deps</code>  specifies the dependencies that, again, only Deps needs to know about</li></ul><p>Under <code>:aliases</code> we'll have a map of, well, aliases. In this case, we want shadow-cljs to know about some <code>:extra-deps</code> (currently empty) and <code>:extra-paths</code>. We'll call that alias <code>:cljs</code>.</p><p>Now back to <code>shadow-cljs.edn</code>:</p><pre><code class="clojure">{:deps
 {:aliases [:cljs]}

 :builds
 {}}
</code></pre><p>Here we tell it to use Deps (via the <code>:deps</code> key) to manage dependencies and source paths.</p><h3 id="step_3:_hello,_world">Step 3: Hello, World<a href="#step_3:_hello,_world"><i class="fas fa-link"></i></a></h3><p>It's about time. Create the following folders: <code>src/main/foo</code>. Inside <code>foo</code>, create <code>core.cljs</code>:</p><pre><code class="clojure">(ns foo.core)

(js/alert "Hello, World")

(println "Hello, World")
</code></pre><p>Now that we have some ClojureScript code, we'll need to compile it and place it under <code>public/js/main.js</code> (since that's where our <code>index.html</code> is pointing to).</p><p>Back to <code>shadow-cljs.edn</code>:</p><pre><code class="clojure">{:deps
 {:aliases [:cljs]}

 :builds
 {:app {:target :browser
        :output-dir "public/js"
        :asset-path "js"
        :modules {:main {:entries [foo.core]}}}}}
</code></pre><p>See the <code>:app</code>? That's how we'll refer to this build configuration when issuing commands to <code>shadow-cljs</code> (more on that in a bit).</p><ul><li><a href="https://shadow-cljs.github.io/docs/UsersGuide.html#target-browser"><code>:target</code></a><blockquote><p> The :browser target produces output intended to run in a Browser environment. During development it supports live code reloading, REPL, CSS reloading. The release output will be minified by the Closure Compiler with :advanced optimizations. </p></blockquote></li><li><code>:output-dir</code> is where our compiled output goes to</li><li><code>:asset-path</code> is the relative path from the root (where the main <code>index.html</code> is) to <code>:output-dir</code></li><li><code>:modules</code> specify output js files. There can be many of them (just like in any other build tool we're used to: Webpack, Rollup, etc.). There's more to them than what we have in the configuration file right now, which is one module, <code>:main</code> (it'll become main.js) and the root namespace, <code>foo.core</code> (we defined that namespace previously in the <code>src/main/foo/core.cljs</code> file).</li></ul><p>We're ready to go. Let's define helper scripts in <code>package.json</code> (feel free to skip this step and issue relevant commands directly):</p><pre><code class="javascript">{
  "scripts": {
    "server": "shadow-cljs server",
    "app:compile": "shadow-cljs compile app",
    "app:release": "shadow-cljs release app"
  },
  "devDependencies": {
    "shadow-cljs": "^2.8.94"
  }
}
</code></pre><p>Our workflow is the following: have one shell session dedicated to running a shadow-cljs server (<code>npm run server</code>). That way, all the other shadow-cljs commands will use that server instance and take much less time to complete. There's even a dashboard you can navigate to:</p><p><code>shadow-cljs - server version: 2.8.94 running at http://localhost:9630</code></p><p>Now that we have our server running, try compiling the cljs code:</p><pre><code class="bash">npm run app:compile
</code></pre><p>You'll see the output in <code>public/js</code>. Now start any static web server like </p><pre><code class="bash">python -m SimpleHTTPServer
</code></pre><p>or skip to the next section where we'll have <code>shadow-cljs</code> do that for us, and navigate to <code>index.html</code>. You should see a Hello, World popup and a message in the console.</p><h3 id="step_4:_all_the_good_things">Step 4: All the Good Things<a href="#step_4:_all_the_good_things"><i class="fas fa-link"></i></a></h3><p>Now â€“ to the cool bits. We'll start slowly and build them up, step by step.</p><p>To start with, add this new script to <code>package.json</code>:</p><pre><code class="javascript">{
  "scripts": {
    "server": "shadow-cljs server",
    "server:repl": "shadow-cljs clj-repl",
    "app:compile": "shadow-cljs compile app",
    "app:release": "shadow-cljs release app"
  },
  "devDependencies": {
    "shadow-cljs": "^2.8.94"
  }
}
</code></pre><p>Run it in a new terminal session:</p><pre><code class="bash">npm run server:repl
</code></pre><p>You'll see a prompt this time around:</p><pre><code class="clojure-repl">shadow-cljs - REPL - see (help)
To quit, type: :repl/quit
shadow.user=&gt;
</code></pre><p>For now, let's treat this prompt like any other prompt from any other REPL (node, etc.). Type the following:</p><pre><code class="clojure-repl">shadow.user=&gt; (ns-aliases *ns*)
</code></pre><p>Which gives us</p><pre><code class="clojure">{shadow "shadow.cljs.devtools.api"]}
</code></pre><p>That's helpful: we can type <code>shadow</code> instead of <code>shadow.cljs.devtools.api</code> to use functions from that namespace. What functions could those be? Let's try compiling our app again:</p><pre><code class="clojure-repl">shadow.user=&gt; (shadow/compile :app)
[:app] Compiling ...
[:app] Build completed. (43 files, 0 compiled, 0 warnings, 0.85s)
:done
</code></pre><p>That's neat: we can do everything from this REPL. Let's add two more scripts to <code>package.json</code> (at this point, more for reference's and completeness' sake than anything else):</p><pre><code class="javascript">"app:watch": "shadow-cljs watch app",
"app:repl": "shadow-cljs cljs-repl app"
</code></pre><p>Back in our repl, let's try</p><pre><code class="clojure-repl">shadow.user=&gt; (shadow/watch :app)
[:app] Configuring build.
[:app] Compiling ...
[:app] Build completed. (135 files, 1 compiled, 0 warnings, 0.93s)
:watching
</code></pre><p>This is the same as running <code>npm run app:watch</code>, only, as we just saw with <code>(shadow/compile :app)</code>, we can do it from the REPL instead, which gives us a lot more control and flexibility (we'll talk more about it during <a href="/posts/2020-03-26-getting-started-with-clojurescript/#~~~_coffee_break_~~~">Coffee Break</a>).</p><p><code>watch</code> is a live-reload feature (again, nothing new so far, but we are going slowly after all). Let's briefly go back to <code>shadow-cljs.edn</code> file and add <code>:dev-http</code>:</p><pre><code class="clojure">{:deps
 {:aliases [:cljs]}

 :dev-http {9000 "public"}
  
 :builds
 {:app {:target :browser
        :output-dir "public/js"
        :asset-path "js"
        :modules {:main {:entries [foo.core]}}}}}
</code></pre><p>That's the static server we talked about previously. Our running server will pick up the changes to the config automatically and display this:</p><p><code>shadow-cljs - HTTP server available at http://localhost:9000</code></p><p>Let's see the live-reload in action while we're at it. Open localhost:9000, change your <code>core.cljs</code> (maybe remove that annoying alert) and save it. You should see a logo in the left-hand corner, and your changes will be picked up and reloaded automatically.</p><p>Now to the <code>app:repl</code> script that we added. Go back to the server repl you still have prompting you for input and type:</p><pre><code class="clojure-repl">shadow.user=&gt; (shadow/repl :app)
cljs.user=&gt;
</code></pre><p>The current namespace changed to <code>cljs.user</code>. Also, our REPL is connected to the browser now! Type</p><pre><code class="clojure-repl">cljs.user=&gt; (println 42)
42
nil
</code></pre><p>42 is printed in our REPL running in a terminal session. <code>nil</code> is the returned value of the <code>(println 42)</code> expression. But look at the console on localhost:9000 and you'll find that 42 made its way there as well.</p><p>Let's try something a bit more interesting:</p><pre><code class="clojure-repl">=&gt; (def hello-world (doto (.createElement js/document "p") (aset "innerHTML" "Hello, World")))
#'cljs.user/hello-world
=&gt; (def app (.getElementById js/document "app"))
#'cljs.user/app
=&gt; (.appendChild app hello-world)
</code></pre><p>Look in your browser â€“ now that's a proper <b>Hello, World</b> example!</p><h3 id="step_5:_the_state_of_the_world">Step 5: The State of the World<a href="#step_5:_the_state_of_the_world"><i class="fas fa-link"></i></a></h3><p>Now for the big finish. Let's add some state and UI to <code>core.cljs</code>:</p><pre><code class="clojure">(ns foo.core)

;; STATE

(defonce state (atom 0))

;; HELPERS

(defn root []
  (.getElementById js/document "app"))

(defn counter []
  (.getElementById js/document "counter"))

(defn replaceChild [root new-child old-child]
  (.replaceChild root new-child old-child))

;; COMPONENTS

(defn new-counter []
  (doto (.createElement js/document "p")
    (.setAttribute "id" "counter")
    (aset "innerHTML" @state)))

(defn new-button-inc []
  (doto (.createElement js/document "button")
    (aset "innerHTML" "+1")
    (aset "onclick" (fn [_event]
                      (swap! state inc)
                      (replaceChild (root) (new-counter) (counter))))))

(defn new-button-reset []
  (doto (.createElement js/document "button")
    (aset "innerHTML" "reset")
    (aset "onclick" (fn [_event]
                      (reset! state 0)
                      (replaceChild (root) (new-counter) (counter))))))

;; RENDER

(defn render [root &amp; components]
  (doseq [c components]
    (.append root c)))

(defn ^:export init
  []
  (aset (root) "innerHTML" "")
  (render (root) (new-counter) (new-button-inc) (new-button-reset)))
</code></pre><p>Save the file and issue the following commands in the REPL:</p><pre><code class="clojure-repl">cljs.user=&gt; (in-ns 'foo.core)
nil
foo.core=&gt; (init)
nil
</code></pre><p>First, we're switching to the <code>foo.core</code> namespace (so we wouldn't have to prefix every command from that namespace, i.e., we could've instead typed <code>(foo.core/init)</code>)</p><p>Then, we call the <code>init</code> function, which renders our UI. Make sure that the buttons work, etc.</p><p>Now, once you're ready, click <code>reset</code> and type <code>@state</code> in the REPL. You should get 0. That's the current value of our <code>state</code>.</p><p>Now, type this:</p><pre><code class="clojure-repl">foo.core=&gt; (reset! state 42)
42
foo.core=&gt; (init)
nil
</code></pre><p>That's interesting: we changed the state from our REPL, and now, re-rendering the UI, the changes are persisting.</p><p>Of course, this is still inefficient â€“ there's too much manual work.</p><p>Let's keep modifying <code>shadow-cljs.edn</code>:</p><pre><code class="clojure">{:deps
 {:aliases [:cljs]}

 :dev-http {9000 "public"}

 :builds
 {:app {:target :browser
        :output-dir "public/js"
        :asset-path "js"
        :modules {:main {:entries [foo.core]
                         :init-fn foo.core/init}}
        :devtools {:repl-init-ns foo.core
                   :after-load foo.core/init}}}}
</code></pre><p><code>:init-fn</code> specifies the function that will be called when the module is loaded initially (refresh <code>localhost:9000</code> to see it in action)</p><p><code>:repl-init-ns</code> will switch the current namespace to <code>foo.core</code> when we connect to a running CLJS repl</p><p><code>:after-load</code> specifies the function to run each time we're live-reloading</p><p>Now go back to the page and give <code>+1</code> a few clicks. Then modify some part of UI in <code>core.cljs</code>. For instance, replace <code>(aset "innerHTML" "+1")</code> with <code>(aset "innerHTML" "plus one")</code> and save the file. Did you notice that the UI has changed while the state stayed the same?</p><p>We're not stopping here, of course. Up until now, we've been using vanilla JavaScript from ClojureScript to render our UI. Now we're going to move to a de-facto standard in the ClojureScript world when it comes to framework-less UI development: <strong>Reagent</strong>.</p><h3 id="step_6:_reagent">Step 6: Reagent<a href="#step_6:_reagent"><i class="fas fa-link"></i></a></h3><p><a href="https://reagent-project.github.io">Reagent</a> bills itself as</p><blockquote><p> Minimalistic React for ClojureScript </p></blockquote><p>Let's bring it in first via <code>deps.edn</code>:</p><pre><code class="clojure">{:paths ["src/dev"]

 :deps  {thheller/shadow-cljs {:mvn/version "2.8.94"}}

 :aliases
 {:cljs
  {:extra-deps {reagent {:mvn/version "0.10.0"}}
   :extra-paths ["src/main" "src/test"]}}}
</code></pre><p>Every time we bring in an external dependency, we have to restart the server. So, kill your REPL and server and run <code>npm run server</code>. This will install Reagent (and React, too!).</p><p>Now let's go back to where we were. You can repeat the steps above or run the scripts we've defined (in two separate terminal sessions â€“ another reason to prefer doing everything from the REPL):</p><pre><code class="bash">npm run app:watch
npm run app:repl
</code></pre><p>In <code>core.cljs</code>:</p><pre><code class="clojure">(ns foo.core
  (:require [reagent.core :as r]
            [reagent.dom :as rdom]))

;; STATE

(defonce state (r/atom 0))

;; COMPONENTS

(defn counter []
  [:p "Counter: " @state])

(defn button-inc []
  [:input {:type "button"
           :value "+1"
           :on-click (fn [_event]
                       (swap! state inc))}])

(defn button-reset []
  [:input {:type "button"
           :value "reset"
           :on-click (fn [_event]
                       (reset! state 0))}])

(defn container []
  [:div
   [counter]
   [button-inc]
   [button-reset]])

;; RENDER

(defn root []
  (.getElementById js/document "app"))

(defn ^:export init []
  (rdom/render [container] (root)))
</code></pre><p>Looks much cleaner, doesn't it? Save, refresh localhost:9000 and click around a bit.</p><p>From your REPL:</p><pre><code class="clojure-repl">foo.core=&gt; (reset! state 42)
</code></pre><p>This changes the state and you can see the update in the UI.</p><p>In <code>core.cljs</code>, replace</p><pre><code class="clojure">:value "+1"
</code></pre><p>with</p><pre><code class="clojure">:value "plus one"
</code></pre><p>and save. Neat, huh? The state stays with us, and is completely under our control, while we're free to change the UI in any way we want.</p><h3 id="~~~_coffee_break_~~~">~~~ Coffee Break ~~~<a href="#~~~_coffee_break_~~~"><i class="fas fa-link"></i></a></h3><p>Naturally, this is just the tip of the iceberg. We came nowhere near a real REPL-driven experience in this tutorial, but hopefully it gave you a taste of what's possible.</p><p>The eventual idea is to connect your editor to a running REPL and evaluate everything from the editor. Once you experience this kind of development, where feedback is immediate and control over state during runtime is as fine-grained as you want, it's really difficult to see the merits of the usual <code>change-&gt;save-&gt;compile-&gt;check-&gt;debug-&gt;change-&gt;etc.</code> cycle.</p><h4 id="parentheses">Parentheses<a href="#parentheses"><i class="fas fa-link"></i></a></h4><p>Let's quickly touch on them. Clojure is a LISP. Like any LISP, it has no syntax â€“ only data structures. List is one of them. Its literal representation is <code>()</code>. There are several ways to create one. Let's use the <code>list</code> function (we'll issue the following commands in the server REPL, so start one with <code>npm run server:repl</code>):</p><pre><code class="clojure-repl">shadow.user=&gt; (list 1 2)
(1 2)
shadow.user=&gt; (type (list 1 2))
clojure.lang.PersistentList
</code></pre><p>The list we've created is <a href="https://en.m.wikipedia.org/wiki/Persistent_data_structure">fully persistent</a>; the implementation of <code>clojure.lang.PersistentList</code> (in Java) can be found <a href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/PersistentList.java">here</a>. Note that a function invocation is also a list:</p><pre><code class="clojure-repl">=&gt; (+ 1 2)
3
=&gt; (list + 1 2)
(#object[clojure.core$_PLUS_ 0x74a72a9d "clojure.core$_PLUS_@74a72a9d"] 1 2)
=&gt; (eval (list + 1 2))
3
</code></pre><p>What if we tried (1 2)?</p><pre><code class="clojure-repl">=&gt; (1 2)
Execution error...
class java.lang.Long cannot be cast to class clojure.lang.IFn
</code></pre><p>So 1, which is <code>java.lang.Long</code>, does not implement <code>clojure.lang.IFn</code> â€“ we cannot invoke 1. What this gives us, the fact that function invocations are lists themselves, is that we end programming in data structures themselves â€“ for all intents and purposes, we program in Abstract Syntax Trees, which are inaccessible to us in many other languages. This gives us, users, the ability to extend the language which usually only the creators of a language have.</p><p>Let's look at two examples. We'll start with a simple one:</p><pre><code class="clojure-repl">shadow.user=&gt; (defmacro debug-plus-10 [expr]
  (let [new-expr (concat expr (list 10))]
    (println "debugging " new-expr)
    new-expr))
</code></pre><p>The ability to access the data structures is realized with macros. Here, we define one with <code>defmacro</code>. Clojure is an eagerly-evaluated language, but macros <i>don't</i> evaluate their arguments. Instead, they return the data structure that will then be evaluated.</p><p>In this case, <code>debug-plus-10</code> expects an expression <code>expr</code>. On the next line, we concat 10 to that expression. Then we print the expression out and return it. Only then will the expression be evaluated.</p><p>Let's try it out:</p><pre><code class="clojure-repl">=&gt; (debug-plus-10 (+ 1 2))
debugging  (+ 1 2 10)
13
</code></pre><p><code>(+ 1 2)</code> is the argument we pass to <code>debug-plus-10</code>. Since it's a list like any other, we can use all the rich sequence API on it. In this case, we use <code>concat</code> to append 10 to the end of the list. We print it out and return the resulting list <code>(+ 1 2 10)</code>, which then gets evaluated to 13.</p><p>And now for something slightly different. Consider C#'s <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement">using</a> statement:</p><pre><code class="c#">using (var font1 = new Font("Arial", 10.0f))
{
    byte charset = font1.GdiCharSet;
}
</code></pre><p><code>Font</code> implements <code>IDisposable</code>. <code>using</code> calls <code>Dispose</code> on the object correctly. But read <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement#remarks">this</a>:</p><blockquote><p> You can achieve the same result by putting the object inside a try block and then calling Dispose in a finally block; <b>in fact, this is how the using statement is translated by the compiler</b>. The code example earlier expands to the following code at compile time (note the extra curly braces to create the limited scope for the object): </p><pre><code class="c#">{
  var font1 = new Font("Arial", 10.0f);
  try
  {
    byte charset = font1.GdiCharSet;
  }
  finally
  {
    if (font1 != null)
      ((IDisposable)font1).Dispose();
  }
}
</code></pre></blockquote><p>If there were no <code>using</code> in C#, you'd have to wait for the designers to put it in. In Clojure, we don't have to wait! Observe:</p><pre><code class="clojure-repl">=&gt; (defmacro using [resource &amp; body]
  `(let [~(get resource 0) ~(get resource 1)]
     (try
      ~@body
      (finally
       (println "getting ready to close stream on file" ~(last (get resource 1)))
       (.close ~(get resource 0))))))
</code></pre><p>The backtick ` means, don't evaluate the following data structure <i>right now</i>, but return it to be evaluated at the call site. The tilde ~ means, <i>do</i> evaluate the following data structure right now.</p><p>Let's try this macro out:</p><pre><code class="clojure-repl">=&gt; (using [fr (new java.io.FileReader "deps.edn")] (println "first char is:" (char (.read fr))))
first char is: {
getting ready to close stream on file deps.edn
nil
</code></pre><p>To sum up,</p><ul><li>Clojure is a LISP</li><li>There's no syntax, only data structures</li><li>We can easily extend the language with macros when we need to</li><li>The workflow involves instant feedback from the running REPL</li></ul><p>There's much more to Clojure itself:</p><ul><li>Mature APIs that operate on sequences (lists, vectors, maps, sets, records, etc.)</li><li>Immutable data structures with APIs and underlying implementation to support their efficient usage</li><li>Mature APIs that deal with concurrency, including software transactional memory (no locks, etc.)</li><li>First-class interop with the host language: Java for Clojure, JavaScript for ClojureScript</li></ul><p>Read more <a href="https://clojure.org/about/rationale">here</a>.</p><p>Of course, Clojure is not a magic bullet and has issues:</p><ul><li>Docs could be better</li><li>Debugging is not always straightforward (doubly so for macros)</li><li>Setting up a development environment takes a bit of work (see more below)</li><li>Adoption in the overall development community is slow</li><li>Error messages expect you to know quite a bit about the language at times</li></ul><p>Despite them, I encourage you to give Clojure(Script) a shot.</p><h4 id="repl_in_space">REPL in Space<a href="#repl_in_space"><i class="fas fa-link"></i></a></h4><p><a href="https://www.youtube.com/watch?v=_gZK0tW8EhQ">Here</a>'s a talk by Dr. Ron Garret on LISP at NASA and debugging a space craft million miles away from Earth using a REPL running on the space craft.</p><h3 id="step_7:_what's_next?">Step 7: What's Next?<a href="#step_7:_what's_next?"><i class="fas fa-link"></i></a></h3><p>Setting up a proper development environment is crucial to a blissful Clojure(Script) experience. You'll be hooking up to running REPLs and evaluating your code straight from the editor! Here are some options:</p><ul><li>IntelliJ + <a href="https://cursive-ide.com">Cursive</a></li><li>VSCode + <a href="https://calva.readthedocs.io">Calva</a></li><li>Emacs + <a href="https://cider.mx">CIDER</a></li><li>Vim + <a href="https://github.com/tpope/vim-fireplace">Fireplace</a></li><li>Atom + <a href="https://atom.io/packages/proto-repl">Proto REPL</a></li><li>Sublime + <a href="https://packagecontrol.io/packages/SublimeREPL">SublimeREPL</a></li></ul><p>You probably see one of your favourite editors in this list â€“ go with it! I've been using IntelliJ and Emacs â€“ both work great. I've heard good things about VSCode and Vim, too.</p><p>If you, like me, learn by reading books, try <a href="https://www.braveclojure.com/clojure-for-the-brave-and-true">Clojure for the Brave and True</a> and <a href="https://pragprog.com/book/shcloj3/programming-clojure-third-edition">Programming Clojure</a>.</p><p>For next steps in front end with ClojureScript, one of the more popular options is <a href="https://github.com/day8/re-frame">re-frame</a>.</p><h3 id="step_8:_addendum">Step 8: Addendum<a href="#step_8:_addendum"><i class="fas fa-link"></i></a></h3><p>There are some thing I'd like to add to this ClojureScript template we've been working on. They are not important enough to be highlighted above, but deserve a mention nonetheless.</p><ul><li><code>deps.edn</code></li></ul><p>Adding a new dependency: <code>binaryage/devtools {:mvn/version "1.0.0"}</code>. It will make ClojureScript values we output to the Chrome DevTools console look nicer.</p><ul><li><code>src/dev/utils.clj</code><pre><code class="clojure">(ns utils
  (:require [shadow.cljs.devtools.api :as shadow]))

(defn watch-and-jack-in-app []
  (shadow/watch :app)
  (shadow/repl :app))
</code></pre></li></ul><p>It's nice to have a helper function.</p><ul><li><code>shadow-cljs.edn</code><pre><code class="clojure"> :nrepl
 {:port 9001
  :init-ns utils}
</code></pre></li></ul><p>Have our server nREPL always start on port 9001 and switch to <code>utils</code> namespace we just defined.</p><h3 id="clone_it!">Clone it!<a href="#clone_it!"><i class="fas fa-link"></i></a></h3><p>The final result is on <a href="https://github.com/danplisetsky/clojurescript-template">GitHub</a>. Hack away!</p>

  

</article>



<p class="post-music">
  <i class="fas fa-headphones"></i>
  <span class="artist">
    Morrissey
  </span>
  â€”
  <span class="song">
    I Wish You Lonely
  </span>
</p>





<p class="post-book">
  <i class="fas fa-book"></i>
  <span class="author">
    Fyodor Dostoevsky
  </span>
  â€”
  <span class="title">
    The Brothers Karamazov
  </span>
</p>



<a class="back-to-blog" href="/archives/">
  <i class="fas fa-long-arrow-alt-left"></i>
  Back to Posts
</a>


  </main>

  <footer>
    <i class="fas fa-ellipsis-h"></i>
  </footer>

</body>

</html>
